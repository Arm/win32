--
-- StdDIS for FFI
--
-- (c) Thomas Nordin and Alastair Reid, 1997, 2003
--

module System.Win32.StdDIS
        ( StablePtr
        , ForeignObj
        , ForeignPtr
        , Ptr
        , FunPtr
        , Int8, Int16, Int32, Int64
        , Word8, Word16, Word32, Word64
        , Addr, nullAddr
        , Storable(..)
        , CString, CChar
        , unsafePerformIO
        , MbString
        , marshall_bool_,      unmarshall_bool_
        , marshall_string_,    unmarshall_string_
        , marshall_stringLen_, unmarshall_stringLen_
        , makeStablePtr, deRefStablePtr, freeStablePtr
        , newForeignPtr, withForeignPtr
        , nullPtr, nullFunPtr
        , funPtrToAddr, addrToFunPtr
        , malloc, free
        , makeForeignObj

	   -- re-exporting base Prelude types
	   -- (useful when generating source that
	   --  import StdDIS qualified.)
	, Float
	, Double
	, Word
	, Int
	, Char
        ) where


import Int( Int8, Int16, Int32, Int64 )
import Word( Word, Word8, Word16, Word32, Word64 )
import Addr( Addr, nullAddr, ptrToAddr, addrToPtr )
import System.IO.Unsafe( unsafePerformIO )
import Foreign(
        Storable(..),
        StablePtr, newStablePtr, deRefStablePtr, freeStablePtr,
        ForeignPtr, newForeignPtr, withForeignPtr,
        Ptr, nullPtr, 
        FunPtr, nullFunPtr,
        castPtrToFunPtr, castFunPtrToPtr,
       	)
import ForeignObj ( ForeignObj, makeForeignObj )
import CString
import CTypes
import qualified MarshalAlloc

#if __GLASGOW_HASKELL__ <= 502
import PrelPtr

ptrToAddr :: Ptr a -> Addr
ptrToAddr (Ptr x) = A# x 

addrToPtr :: Addr -> Ptr a
addrToPtr (A# x) = Ptr x

#endif

funPtrToAddr :: FunPtr a -> Addr
funPtrToAddr = ptrToAddr . castFunPtrToPtr

addrToFunPtr :: Addr -> FunPtr a
addrToFunPtr = castPtrToFunPtr . addrToPtr

makeStablePtr = newStablePtr

%dis char x             = %%Char   ({HsChar}   x)
%dis int x              = %%Int    ({HsInt}    x)
%dis float x            = %%Float  ({HsFloat}  x)
%dis double x           = %%Double ({HsDouble} x)
%dis addr x             = %%Addr   ({void *}   x)
%dis ptr x              = %%Ptr    ({HsPtr}    x)
%dis funPtr x           = %%FunPtr ({HsFunPtr} x)

%dis int8 x             = %%Int8   ({HsInt8}   x)
%dis int16 x            = %%Int16  ({HsInt16}  x)
%dis int32 x            = %%Int32  ({HsInt32}  x)

%dis word8 x            = %%Word8  ({HsWord8}  x)
%dis word16 x           = %%Word16 ({HsWord16} x)
%dis word32 x           = %%Word32 ({HsWord32} x)

#if defined (__GLASGOW_HASKELL__)
%dis byteArray x        = %%ByteArray ({void *} x)
%dis mutableByteArray x = %%MutableByteArray ({void *} x)
#endif

%dis maybeT z x         = %Maybe z x
%dis maybe x            = maybeT {0} x

%dis bool x             = bool_ (int x)

marshall_bool_ :: Bool -> IO Int
marshall_bool_ True  = return 1
marshall_bool_ False = return 0

unmarshall_bool_ :: Int -> IO Bool
unmarshall_bool_ 0 = return False
unmarshall_bool_ _ = return True

-- Ignore "IO" part of result type
%dis iO x = x

----------------------------------------------------------------
-- Strings
----------------------------------------------------------------

%dis cString x     = ptr ({char *} x)
%dis string x      = string_    (ptr ({char *} x))
%dis stringLen x l = stringLen_ (ptr ({char *} x)) (int l)

type MbString      = Maybe String
%dis mbString x    = maybeT {nullPtr} (string x)

marshall_string_ :: [Char] -> IO CString
marshall_string_ = newCString

marshall_stringLen_ :: [Char] -> IO (CString, Int)
marshall_stringLen_ = newCStringLen

unmarshall_string_ :: CString -> IO String
unmarshall_string_ = peekCString

unmarshall_stringLen_ :: CString -> Int -> IO String
unmarshall_stringLen_ ptr l = peekCStringLen (ptr, l)

----------------------------------------------------------------
-- malloc/free (deprecated)
----------------------------------------------------------------

malloc :: Word32 -> IO Addr
malloc sz = MarshalAlloc.mallocBytes (fromIntegral sz) >>= return.ptrToAddr

free :: Addr -> IO ()
free p = MarshalAlloc.free (addrToPtr p)
 
-- what does this actually do?
%dis free x             = freeAux x

----------------------------------------------------------------
-- Stable pointers
----------------------------------------------------------------

--
-- Use "stable" to create a stable pointer
-- 
-- Use "stablePtr" to manipulate (previously constructed) stable pointers 
-- in Haskell.
--
%dis stable x = 
%   declare {HsStablePtr} x in 
%   << makeStablePtr / deRefStablePtr / %%StablePtr >> x

%dis stablePtr x = (%%StablePtr ({HsStablePtr} x))

----------------------------------------------------------------
-- Foreign Objects (deprecated)
----------------------------------------------------------------

-- %foreign will convert an Addr into a ForeignObj
%dis foreign x free     = %Foreign {void*} x free
%dis foreignPtr x       = foreign x {free}

%dis foreignObj x = foreign x {free}

----------------------------------------------------------------
-- Foreign pointers
----------------------------------------------------------------

--
-- Use "foreignP" to create a stable pointer
-- 
-- Use "foreignPtr" to manipulate (previously constructed) foreign pointers 
-- in Haskell.
--
%dis foreign x = 
%   declare {HsForeignPtr} x in 
%   << newForeignPtr / withForeignPtr / %%ForeignPtr >> x

%dis foreignPtr x = %%ForeignPtr ({HsForeignPtr} x)

----------------------------------------------------------------
-- End of StdDIS
----------------------------------------------------------------
